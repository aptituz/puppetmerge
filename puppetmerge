#!/usr/bin/env ruby

require 'English'
require 'optparse'
require 'ostruct'
require 'highline/import'
require 'find'
require 'fileutils'
require 'diffy'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), *%w[lib])
require 'puppetmerge'

opt_parser = PuppetMerge::OptParser.build
opt_parser.parse!

#print opts.inspect
opts = PuppetMerge.configuration

if PuppetMerge.configuration.source == PuppetMerge.configuration.target
  puts 'source and target module are the same, that makes no sense'
  Kernel.exit(1)
end

unless File.directory?(opts.source)
  puts "specified source directory `#{opts.source}' is not a directory"
  Kernel.exit(1)
end

unless File.directory?(opts.target)
  puts "specified destination directory `#{opts.target}' is not a directory"
  Kernel.exit(1)
end

unless File.exist?(File.join(opts.source, 'manifests', 'init.pp'))
  puts 'specified source does not have an init.pp - wrong path?'
  Kernel.exit(1)
end

def copy(src, dest, flags)
  parent = File.dirname(dest)
  FileUtils.mkdir_p(parent, flags) unless File.exist?(parent)
  FileUtils.cp(src, dest, flags)
end

# Diff class based on Diffy::Diff but with some additional error handling

class PatchException < Exception; end

def accept_diff?(message = 'Accept difference? (yes, no, edit)', char = nil)
  ask message do |q|
    q.validate = /\Ay(?:es)?|no?|edit?\Z/i
    q.responses[:not_valid]    = 'Please enter "yes", "no" or "edit".'
    q.responses[:ask_on_error] = :question
    q.character                = char

    yield q if block_given?
  end
end

def edit_patch(path, otherpath, opts)
  # FIXME: error handling?
  begin
    system('editdiff', path)
    apply_patch(otherpath, path) unless opts.flags[:noop]
  rescue PatchException
    retry if agree 'applying patch failed, edit again? (yes, no)'
    raise PatchException
  end

  #origfile = tmpfile.path + '.orig'
  #File.unlink(origfile) if File.exist?(origfile)
end

def edit_and_apply_patch(diff, otherpath, opts)
  tmpfile = nil
  begin
    tmpfile = Tempfile.new('puppetmerge')
    tmpfile.write(diff)
    tmpfile.close

    edit_patch(tmpfile.path, otherpath, opts)
  ensure
    tmpfile.close
    tmpfile.unlink
  end
end

def apply_patch(path, patchfile)
  if system('patch', path, patchfile).nil?
    fail 'unable to execute patch: ' + $CHILD_STATUS.to_s
  end

  fail PatchException, 'applying patch failed' if $CHILD_STATUS.exitstatus != 0
end

PuppetMerge::Diff.default_options.merge!(
  source: 'files',
  diff: opts.diff_args,
  include_diff_info: true,
  default_format: :color
)

sourcefiles = PuppetMerge::Files.new(opts.source, opts.target)

sourcefiles.newfiles do |file|
  copy_file = false
  if opts.copy_new
    copy_file = true
  else
    puts file.content_as_diff
    puts "File #{file.relative_path} is new."
    copy_file = true if agree("Accept new file? (yes, no)")
  end

  file.copy_to_target if copy_file
end

sourcefiles.changedfiles do |file|
  begin
    diff = PuppetMerge::Diff.new(file.target, file.to_s)
    next if diff.to_s.empty?
    puts diff
    puts "affected file: #{file.relative_path}"
    response = accept_diff?

    if response == 'yes'
      file.copy_to_target
    elsif response == 'edit'
      edit_and_apply_patch(diff, file.target, opts)
    end
  rescue PatchException
    retry
  end
end
