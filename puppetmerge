#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'highline/import'
require 'find'
require 'fileutils'
require 'diffy'

opts = OpenStruct.new
opts.source = '.'
opts.target = '.'
opts.copy_new = false
opts.debug = false
opts.flags = {}

opt_parser = OptionParser.new do |opt|
  opt.banner = "Usage: puppetmerge [OPTIONS] source destination"
   opt.separator  ""
   opt.separator  "Options"

   opt.on("--debug","Enable debug mode") do |arg|
     opts.debug = arg
   end
   
   opt.on("--verbose", "Be verbose") do |arg|
     opts.flags[:verbose] = arg
   end
   
   opt.on("--noop", "Do not actually do anything") do |arg|
     opts.flags[:noop] = arg
   end
   
   opt.on("--copy-new", "Copy new files without confirmation") do |arg|
     opts.copy_new = arg
   end
   
   opt.on("-s", "--source SOURCEDIR", "Specify source directory (default: $PWD)") do |s|
     opts.source = File.absolute_path(s)
   end

   opt.on("-d", "--destination DESTDIR", "Specify destination directory (default: $PWD)") do |d|
     opts.target = File.absolute_path(d)
   end
   
   opt.on("-h","--help","help") do
     puts opt_parser
   end
end

opt_parser.parse!

if opts.source == opts.target
  puts "source and target module are the same, that makes no sense"
  Kernel.exit(1)
end

unless File.directory?(opts.source)
  puts "specified source directory `%s' is not a directory" % opts.source
  Kernel.exit(1)
end

unless File.directory?(opts.target)
  puts "specified destination directory `%s' is not a directory" % opts.target
  Kernel.exit(1)
end

unless File.exists?(File.join(opts.source, "manifests", "init.pp" ))
  puts "specified source does not have an init.pp - wrong path?"
  Kernel.exit(1)
end

def find_source_files(opts)
  if not block_given?
    raise ArgumentError('find_soure_files requires a block')
  end
  Find.find(opts.source) do |path|
    relpath = path.sub(opts.source + '/', '')
    otherpath = File.join(opts.target, relpath)
    if FileTest.directory?(path)
      if File.basename(path) =~ /(.svn|.git)/
        Find.prune
      end
    else
      yield path, relpath, otherpath
    end
  end
end

def copy(src, dest, flags)
  parent = File.dirname(dest)
  unless File.exist?(parent)
    FileUtils.mkdir_p(parent, flags)
  end
  FileUtils.cp(src, dest, flags)
end


Diffy::Diff.default_options.merge!(
  :source => 'files',
  :diff   => '-uw',
  :include_diff_info => true,
  :default_format => :color
)
Diffy::Diff.default_format = :color

find_source_files(opts) do |ourpath, our_relpath, otherpath| 
    puts "testing #{ourpath} against #{otherpath}" if opts.flags[:verbose]

    copy_file = false
    # skip over identical files
    if File.exists?(otherpath) and FileUtils.compare_file(ourpath, otherpath)
      puts "file '#{our_relpath}' identical, next" if opts.debug
      next
    end

    # no need to diff if file is not there
    if File.exists?(otherpath)
      puts Diffy::Diff.new(ourpath, otherpath).diff
      copy_file = agree("Accept difference? (yes, no)")
    else
      if opts.copy_new
        copy_file = true
      else
        copy_file = agree("File #{our_relpath} is new on destination - copy? (yes, no)")
      end
    end

    if copy_file
      copy(ourpath, otherpath, opts.flags)
    end
  end
