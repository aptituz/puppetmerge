#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'highline/import'
require 'find'
require 'fileutils'
require 'diffy'

opts = OpenStruct.new
opts.source = '.'
opts.target = '.'
opts.copy_new = false
opts.debug = false
opts.flags = {}
opts.diff_args = ['-wu']

opt_parser = OptionParser.new do |opt|
  opt.banner = "Usage: puppetmerge [OPTIONS] source destination"
   opt.separator  ""
   opt.separator  "Options"

   opt.on("--debug","Enable debug mode") do |arg|
     opts.debug = arg
   end
   
   opt.on("--verbose", "Be verbose") do |arg|
     opts.flags[:verbose] = arg
   end
   
   opt.on("--noop", "Do not actually do anything") do |arg|
     opts.flags[:noop] = arg
   end
   
   opt.on("--diff-args ARGS", "Specify additional arguments to diff cmd") do |args|
     opts.diff_args << args
   end

   opt.on("--copy-new", "Copy new files without confirmation") do |arg|
     opts.copy_new = arg
   end
   
   opt.on("-s", "--source SOURCEDIR", "Specify source directory (default: $PWD)") do |s|
     opts.source = File.absolute_path(s)
   end

   opt.on("-d", "--destination DESTDIR", "Specify destination directory (default: $PWD)") do |d|
     opts.target = File.absolute_path(d)
   end
   
   opt.on("-h","--help","help") do
     puts opt_parser
   end
end

opt_parser.parse!

if opts.source == opts.target
  puts "source and target module are the same, that makes no sense"
  Kernel.exit(1)
end

unless File.directory?(opts.source)
  puts "specified source directory `%s' is not a directory" % opts.source
  Kernel.exit(1)
end

unless File.directory?(opts.target)
  puts "specified destination directory `%s' is not a directory" % opts.target
  Kernel.exit(1)
end

unless File.exists?(File.join(opts.source, "manifests", "init.pp" ))
  puts "specified source does not have an init.pp - wrong path?"
  Kernel.exit(1)
end

def find_source_files(opts)
  if not block_given?
    raise ArgumentError('find_soure_files requires a block')
  end
  Find.find(opts.source) do |path|
    relpath = path.sub(opts.source + '/', '')
    otherpath = File.join(opts.target, relpath)
    if FileTest.directory?(path)
      if File.basename(path) =~ /(.svn|.git)/
        Find.prune
      end
      
      if File.basename(path) =~ /\.orig$/
        Find.prune
      end
    else
      yield path, relpath, otherpath
    end
  end
end

def copy(src, dest, flags)
  parent = File.dirname(dest)
  unless File.exist?(parent)
    FileUtils.mkdir_p(parent, flags)
  end
  FileUtils.cp(src, dest, flags)
end

class PuppetDiffer < Diffy::Diff
  def diff
    # NOTE: We do not support all options of Diffy:Diff
    @diff ||= begin
      paths = [string1, string2]

      puts [diff_bin,  *(diff_options + paths)].join(" ")
      diff = Open3.popen3(diff_bin, *(diff_options + paths)) do |i, o, e|
        err = e.read
        unless err.empty?
          raise "An error occured (retval #{exit_status}): #{err}"
        end
        o.read
      end
      diff.force_encoding('ASCII-8BIT') if diff.respond_to?(:valid_encoding?) && !diff.valid_encoding?
      if diff =~ /\A\s*\Z/ && !options[:allow_empty_diff]
        diff = File.read(string1).gsub(/^/, " ")
      end
      diff
    end
  end
end

class PatchException < Exception
end
  

def accept_diff?(character = nil)
  ask "Accept difference? (yes, no, edit)" do |q|
    q.validate = /\Ay(?:es)?|no?|edit?\Z/i
    q.responses[:not_valid]    = 'Please enter "yes", "no" or "edit".'
    q.responses[:ask_on_error] = :question
    q.character                = character
    
    yield q if block_given?
  end
end

def edit_and_apply_patch(diff, otherpath, opts)
  tmpfile = nil
  begin
    tmpfile = Tempfile.new('puppetmerge')
    tmpfile.write(diff)
    tmpfile.close
    
    # FIXME: error handling?
    begin
      system('editdiff', tmpfile.path)
      unless opts.flags[:noop]
        apply_patch(otherpath, tmpfile.path)
      end
    rescue PatchException
      if agree "applying patch failed, edit again? (yes, no)"
        retry
      else
        raise PatchException
      end
    end 

    origfile = tmpfile.path + ".orig"
    if File.exists?(origfile)
      puts "Removing origfile"
        File.unlink(origfile)
    end
  ensure
    tmpfile.close
    tmpfile.unlink
  end
end

def apply_patch(path, patchfile)
  if system('patch', path, patchfile).nil?
    raise "unable to execute patch: " + $?.to_s
  end
  
  if $?.exitstatus != 0
    raise PatchException.new
  end
end

PuppetDiffer.default_options.merge!(
  :source => 'files',
  :diff   => opts.diff_args,
  :include_diff_info => true,
  :default_format => :color
)
Diffy::Diff.default_format = :color

find_source_files(opts) do |ourpath, our_relpath, otherpath| 
    puts "testing #{ourpath} against #{otherpath}" if opts.flags[:verbose]

    begin
      copy_file = false
      # skip over identical files
      if File.exists?(otherpath) and FileUtils.compare_file(ourpath, otherpath)
        puts "file '#{our_relpath}' identical, next" if opts.debug
        next
      end

      # no need to diff if file is not there
      if File.exists?(otherpath)
        diff = PuppetDiffer.new(otherpath, ourpath)
        puts diff
        copy_file = accept_diff?
      else
        if opts.copy_new
          copy_file = true
        else
          copy_file = agree("File #{our_relpath} is new on destination - copy? (yes, no)")
        end
      end

      if copy_file == 'yes' or copy_file == true
        copy(ourpath, otherpath, opts.flags)
      elsif copy_file == 'edit'
        edit_and_apply_patch(diff, otherpath, opts)
      end
    rescue PatchException => e
      retry
    end
end