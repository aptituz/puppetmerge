#!/usr/bin/env ruby

require 'English'
require 'optparse'
require 'ostruct'
require 'highline/import'
require 'find'
require 'fileutils'
require 'diffy'

$LOAD_PATH.unshift File.join(File.dirname(__FILE__), *%w[lib])
require 'puppetmerge'

opts = OpenStruct.new
opts.source = '.'
opts.target = '.'
opts.copy_new = false
opts.debug = false
opts.flags = {}
opts.diff_args = ['-Nwu']

opt_parser = OptionParser.new do |opt|
  opt.banner = 'Usage: puppetmerge [OPTIONS] source destination'
  opt.separator ''
  opt.separator 'Options'

  opt.on('--debug', 'Enable debug mode') do |arg|
    opts.debug = arg
  end

  opt.on('--verbose', 'Be verbose') do |arg|
    opts.flags[:verbose] = arg
  end

  opt.on('--noop', 'Do not actually do anything') do |arg|
    opts.flags[:noop] = arg
  end

  opt.on('--diff-args ARGS',
         'Specify additional arguments to diff cmd') do |args|
    opts.diff_args << args
  end

  opt.on('--copy-new', 'Copy new files without confirmation') do |arg|
    opts.copy_new = arg
  end

  opt.on('-s', '--source SOURCEDIR',
         'Specify source directory (default: $PWD)') do |s|
    opts.source = File.absolute_path(s)
  end

  opt.on('-d', '--destination DESTDIR',
         'Specify destination directory (default: $PWD)') do |d|
    opts.target = File.absolute_path(d)
  end

  opt.on('-h', '--help', 'help') do
    puts opt_parser
  end
end

opt_parser.parse!

if opts.source == opts.target
  puts 'source and target module are the same, that makes no sense'
  Kernel.exit(1)
end

unless File.directory?(opts.source)
  puts "specified source directory `#{opts.source}' is not a directory"
  Kernel.exit(1)
end

unless File.directory?(opts.target)
  puts "specified destination directory `#{opts.target}' is not a directory"
  Kernel.exit(1)
end

unless File.exist?(File.join(opts.source, 'manifests', 'init.pp'))
  puts 'specified source does not have an init.pp - wrong path?'
  Kernel.exit(1)
end

def copy(src, dest, flags)
  parent = File.dirname(dest)
  FileUtils.mkdir_p(parent, flags) unless File.exist?(parent)
  FileUtils.cp(src, dest, flags)
end

# Diff class based on Diffy::Diff but with some additional error handling

class PatchException < Exception; end

def accept_diff?(message = 'Accept difference? (yes, no, edit)', char = nil)
  ask message do |q|
    q.validate = /\Ay(?:es)?|no?|edit?\Z/i
    q.responses[:not_valid]    = 'Please enter "yes", "no" or "edit".'
    q.responses[:ask_on_error] = :question
    q.character                = char

    yield q if block_given?
  end
end

def edit_patch(path, otherpath, opts)
  # FIXME: error handling?
  begin
    system('editdiff', path)
    apply_patch(otherpath, path) unless opts.flags[:noop]
  rescue PatchException
    retry if agree 'applying patch failed, edit again? (yes, no)'
    raise PatchException
  end

  #origfile = tmpfile.path + '.orig'
  #File.unlink(origfile) if File.exist?(origfile)
end

def edit_and_apply_patch(diff, otherpath, opts)
  tmpfile = nil
  begin
    tmpfile = Tempfile.new('puppetmerge')
    tmpfile.write(diff)
    tmpfile.close

    edit_patch(tmpfile.path, otherpath, opts)
  ensure
    tmpfile.close
    tmpfile.unlink
  end
end

def apply_patch(path, patchfile)
  if system('patch', path, patchfile).nil?
    fail 'unable to execute patch: ' + $CHILD_STATUS.to_s
  end

  fail PatchException, 'applying patch failed' if $CHILD_STATUS.exitstatus != 0
end

PuppetMerge::Diff.default_options.merge!(
  source: 'files',
  diff: opts.diff_args,
  include_diff_info: true,
  default_format: :color
)

sourcefiles = PuppetMerge::Files.new(opts.source, opts.target)

sourcefiles.newfiles do |file|
  copy_file = false
  if opts.copy_new
    copy_file = true
  else
    puts file.content_as_diff
    puts "File #{file.relative_path} is new."
    copy_file = true if agree("Accept new file? (yes, no)")
  end

  file.copy_to_target if copy_file
end

sourcefiles.changedfiles do |file|
  begin
    diff = PuppetMerge::Diff.new(file.target, file.to_s)
    next if diff.to_s.empty?
    puts diff
    puts "affected file: #{file.relative_path}"
    response = accept_diff?

    if response == 'yes'
      file.copy_to_target
    elsif response == 'edit'
      edit_and_apply_patch(diff, file.target, opts)
    end
  rescue PatchException
    retry
  end
end
